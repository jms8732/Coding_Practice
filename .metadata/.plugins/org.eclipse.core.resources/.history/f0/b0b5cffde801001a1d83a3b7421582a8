package programmers;
//섬 연결하기

import java.util.*;
public class problem_31 {
	static int cost[][];
	public static void main(String[] args) {
		int [][]tmp = {{0,1,1},{0,2,2},{1,2,5},{1,3,1},{2,3,8}};
		int result = solution(4,tmp);
		System.out.println(result);
	}
	public static int solution(int n, int[][] costs) {
		cost = new int [n][n];
		for(int i = 0 ; i< costs.length ; i++) {
			cost[costs[i][0]][costs[i][1]] = costs[i][2]; //비용 추가
			cost[costs[i][1]][costs[i][0]] = costs[i][2]; //무 방향성이므로 반대쪽도 추가
		}
		
		bfs(0);
        int answer = 0;
        return answer;
    }
	
	public static void bfs(int x) {
		Queue<Integer> queue= new LinkedList<>();
		for(int i =0 ; i< cost[x].length ; i++) {
			if(cost[x][i] != 0)
			{
				queue.add(i); //y좌표 삽입
			}
		}
	
		island first=  new island(x,0,queue,new boolean[cost.length]);
		
		Queue<island> q = new LinkedList<>();
		q.add(first);
		int totalCost = Integer.MAX_VALUE;
		while(!q.isEmpty()) {
			island tmp = q.poll();
			int tmpX = tmp.current;
			if(tmp.next.isEmpty())
				totalCost = Math.min(totalCost, tmp.cost);
			while(!tmp.next.isEmpty()) {
				int y= tmp.next.poll(); //다음 좌표
				boolean visited[] = tmp.visited;
				visited[tmpX] = true; //현재 좌표 방문 완료
				int tmpCost = cost[tmpX][y] + tmp.cost;
				Queue<Integer> tmpQueue = new LinkedList<>();
				for(int i = 0 ; i < cost[y].length; i++) {
					if(cost[y][i] != 0 && !visited[i]) //방문한적도 없으면서 동시에 비용이 있을 때
						tmpQueue.add(i);
				}
				
				island i = new island(y,tmpCost,tmpQueue,visited);
				q.add(i);
			}
		}
		
	}
}

class island{
	int current;
	Queue<Integer> next;
	int cost =0 ;
	boolean visited[];
	public island(int current,int cost, Queue<Integer> queue, boolean [] visited) {
		this.visited = new boolean[visited.length];
		System.arraycopy(visited,0,this.visited,0,visited.length);
		this.current = current;
		next = new LinkedList<>(queue);
		this.cost += cost;
		
	}
}
