package programmers2;

import java.util.*;

public class problem_11 {
	public static void main(String[] args) {
		int[][] answer = solution(2);

		for (int i[] : answer) {
			for (int j = 0; j < i.length; j++) {
				System.out.print(i[j] + " ");
			}
			System.out.println();
		}
	}

	public static int[][] solution(int n) {
		Queue<Node> queue = new LinkedList<>();
		Deque<Integer> list = new LinkedList<>();
		Deque<Integer> dq[] = new LinkedList[3];

		// 첫 번째 기둥에 원판을 순서대로 넣기
		for (int i = 1; i <= n; i++)
			list.offer(i);

		for (int i = 0; i < dq.length; i++)
			dq[i] = new LinkedList<>();

		int currentPosition = 0;
		dq[0] = list;
		int value = list.pollFirst();

		// 맨 처음 값 넣기
		for (int i = 0; i < 3; i++) {
			List<Integer> tmpList = new ArrayList<>();
			if (i != currentPosition) {
				Queue<List<Integer>> tmpQueue = new LinkedList<>();
				tmpList.add(currentPosition + 1);
				tmpList.add(i + 1);

				dq[i].offer(value);
				tmpQueue.add(tmpList);
				queue.add(new Node(dq, tmpQueue));
				dq[i].poll();
			}
		}

		int[][] answer = null;

		while (!queue.isEmpty()) {
			Node current = queue.poll();
			Deque<Integer>[] currentlist = current.list;
			Deque<Integer>[] tmplist = new LinkedList[3];
			Queue<List<Integer>> cq = current.answer;
			Queue<List<Integer>> tmpQueue = new LinkedList<>(cq);
			
			
			if (isFinish(currentlist, n)) {
				answer = new int[cq.size()][2];
				copyAnswer(answer, cq);
				break;
			}

			
			for (int i = 0; i < 3; i++) {
				int cp = i;
				int cv = 0;
				if (!currentlist[i].isEmpty())
					cv = currentlist[i].peek();

				for (int j = 0; j < 3; j++) {
					List<Integer> tmpList = new ArrayList<>();
					if (cp != j) {
						// 현재 기둥에 다른 기둥
						int apv = 0;

						if (!currentlist[j].isEmpty())
							apv = currentlist[j].peek();

						if (cv < apv || currentlist[j].isEmpty()) {
							// 다른 기둥에 값이 현재 꺼낸 원판보다 값이 클 경우
							tmplist = copyArray(currentlist);
							currentlist[j].addFirst(cv); // 현재 위치의 앞에 넣을 수 있다.
							currentlist[i].poll();
							tmpList.add(cp + 1);
							tmpList.add(j + 1);
							cq.add(tmpList);
							queue.add(new Node(currentlist, cq));
							currentlist = copyArray(tmplist);
							cq = new LinkedList<>(tmpQueue);
						}
					}
				}
			}

		}
		return answer;
	}

	private static void copyAnswer(int[][] answer, Queue<List<Integer>> queue) {
		int rowIdx = 0;
		while (!queue.isEmpty()) {
			List<Integer> list = queue.poll();
			for (int i = 0; i < list.size(); i++) {
				answer[rowIdx][i] = list.get(i);
			}
			rowIdx++;
		}
	}

	private static boolean isFinish(Deque<Integer> dq[], int n) {
		if (dq[2].size() == n)
			return true;
		return false;
	}

	// 배열 값 복사
	private static Deque<Integer>[] copyArray(Deque<Integer>[] src) {
		Deque<Integer>[] tmp = new Deque[3];
		for (int i = 0; i < src.length; i++) {
			tmp[i] = new LinkedList<>(src[i]);
		}

		return tmp;
	}

	private static class Node {
		Deque<Integer> list[];
		Queue<List<Integer>> answer;

		public Node(Deque<Integer>[] list, Queue<List<Integer>> position) {
			this.list = new LinkedList[3];
			copyArray(list);
			this.answer = new LinkedList<>(position);
		}

		// 배열 복사
		private void copyArray(Deque<Integer>[] list) {
			for (int i = 0; i < list.length; i++) {
				this.list[i] = new LinkedList<>(list[i]);
			}
		}
	}
}
