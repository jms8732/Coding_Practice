package samsung;
//연산자 끼워넣기

import java.io.IOException;
import java.util.*;
import java.io.*;

public class problem_14888 {
	static long big,small;
	static int N;
	public static void main(String[] args) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st =null;
		int [] op = new int[4]; //연산자의 개수를 넣는 배열
		Deque<Long> queue = new LinkedList<>(); //수를 담기 위한 큐
		
		Queue<Node> q = new LinkedList<>(); //BFS를 진행하기 위한 큐
		
		try {
			st =new StringTokenizer(br.readLine());
			N = Integer.parseInt(st.nextToken());
			
			st =new StringTokenizer(br.readLine());
			for(int i = 0 ; i < N ;i ++) {
				queue.add(Long.parseLong(st.nextToken())); //수 대입
			}
			
			st =new StringTokenizer(br.readLine());
			for(int i =0 ; i< 4 ; i++)
				op[i] = Integer.parseInt(st.nextToken());
			
			
			br.close();
			long f = queue.poll();
			long e = queue.poll();
			
			for(int i =0 ; i< 4 ; i++) {
				if(op[i] != 0) {
					long value =0;
					switch(i) {
					case 0:
						value = f+e;
						break;
					case 1:
						value = f-e;
						break;
					case 2:
						value = f*e;
						break;
					case 3:
						value = f/e; //수정 필
						break;
					}
					queue.addFirst(value); //새로 생긴 값 맨 앞에 추가
					
				}
			}
			
		}catch(IOException e) {
			e.printStackTrace();
		}
	}
	private static class Node{
		long value;
		Deque<Integer> queue;
		int[] op;
		public Node(int v, Deque<Integer> q , int[] op) {
			this.value = v;
			this.queue = new LinkedList<>(q);
			this.op = new int[4];
			System.arraycopy(op, 0, this.op, 0, op.length);
		}
	}
}
