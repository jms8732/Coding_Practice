package programmers2;

import java.util.*;

public class problem_11 {
	public static void main(String[] args) {
		int[][] answer = solution(2);

		for (int i[] : answer) {
			for (int j = 0; j < i.length; j++) {
				System.out.print(i + " ");
			}
			System.out.println();
		}
	}

	public static int[][] solution(int n) {
		Queue<Node> queue = new LinkedList<>();
		Deque<Integer> list = new LinkedList<>();
		Deque<Integer> dq[] = new LinkedList[3];

		// 첫 번째 기둥에 원판을 순서대로 넣기
		for (int i = 0; i < n; i++)
			list.offer(i + 1);

		for (int i = 0; i < dq.length; i++)
			dq[i] = new LinkedList<>();

		int currentPosition = 0;

		int value = list.pollFirst();

		// 맨 처음 값 넣기
		for (int i = 0; i < 3; i++) {
			List<Integer> tmpList = new ArrayList<>();
			if (i != currentPosition) {
				Queue<List<Integer>> tmpQueue = new LinkedList<>();
				tmpList.add(currentPosition);
				tmpList.add(i);

				dq[i].offer(value);
				tmpQueue.add(tmpList);
				queue.add(new Node(dq, tmpQueue));
				dq[i].poll();
			}
		}

		int[][] answer = null;

		while (!queue.isEmpty()) {
			Node current = queue.poll();
			Deque<Integer>[] currentlist = current.list;
			Deque<Integer>[] tmplist = new LinkedList[3];
			Queue<List<Integer>> cq = current.answer;
			Queue<List<Integer>> tmpQueue = null;

			copyPosition(cq, tmpQueue);

			for (int i = 0; i < 3; i++) {
				int cp = i;
				int cv = currentlist[i].peek();

				if (isFinish(currentlist, n)) {
					answer = new int[cq.size()][2];
					copyAnswer(answer, cq);
					break;
				}

				for (int j = 0; j < 3; j++) {
					List<Integer> tmpList = new ArrayList<>();
					if (cp != j) {
						// 현재 기둥에 다른 기둥
						int apv = currentlist[j].peek();
						if (cv < apv) {
							// 다른 기둥에 값이 현재 꺼낸 원판보다 값이 클 경우
							copyArray(currentlist, tmplist);
							currentlist[j].addFirst(cv); // 현재 위치의 앞에 넣을 수 있다.
							currentlist[i].poll();
							tmpList.add(cp);
							tmpList.add(j);
							cq.add(tmpList);
							queue.add(new Node(currentlist, cq));
							copyArray(tmplist, currentlist);
							copyPosition(tmpQueue, cq);
						}
					}
				}
			}

		}
		return answer;
	}

	private static void copyPosition(Queue<List<Integer>> src, Queue<List<Integer>> dest) {
		dest = new LinkedList<>(src);
	}

	private static void copyAnswer(int[][] answer, Queue<List<Integer>> queue) {
		int rowIdx = 0;
		while (!queue.isEmpty()) {
			List<Integer> list = queue.poll();
			for (int i = 0; i < list.size(); i++) {
				answer[rowIdx++][i] = list.get(i);
			}
		}
	}

	private static boolean isFinish(Deque<Integer> dq[], int n) {
		if (dq[2].size() == n)
			return true;
		return false;
	}

	// 배열 값 복사
	private static void copyArray(Deque<Integer>[] src, Deque<Integer>[] dest) {
		for (int i = 0; i < src.length; i++) {
			dest[i] = new LinkedList<>(src[i]);
		}
	}

	private static class Node {
		Deque<Integer> list[];
		Queue<List<Integer>> answer;

		public Node(Deque<Integer>[] list, Queue<List<Integer>> position) {
			this.list = new LinkedList[3];
			copyArray(list);
			this.answer = new LinkedList<>(position);
		}

		// 배열 복사
		private void copyArray(Deque<Integer>[] list) {
			for (int i = 0; i < list.length; i++) {
				this.list[i] = new LinkedList<>(list[i]);
			}
		}
	}
}
