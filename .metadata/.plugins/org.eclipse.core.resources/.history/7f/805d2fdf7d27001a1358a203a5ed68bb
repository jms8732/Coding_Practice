package programmers1;

//리틀 프랜즈

import java.util.*;

public class problem_17 {
	static boolean[][] visited;

	public static void main(String[] args) {

	}

	public static String solution(int m, int n, String[] board) {
		char[][] map = new char[m][n];
		Stack<Node> stack = new Stack<>(); // 제거될 좌표들이 저장돼 있는 stack
		visited = new boolean[m][n]; // 해당 좌표의 값이 방문했는지 판단하기 위한 값
		// map 초기화
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				map[i][j] = board[i].charAt(j);
			}
		}

		boolean check = false;
		while (!check) {
			check = true;
			for (int i = 0; i < m; i++) {
				for (int j = 0; j < n; j++) {
					if (map[i][j] >= 'A' && map[i][j] <= 'Z' && !visited[i][j]) {
						// 해당 좌표에 문자가 존재할 경우
						visited[i][j] = true;
						dfs(0, i, j, map[i][j], stack);
					}
				}
			}

			if (!stack.isEmpty()) {
				removeChar(stack, map); // stack에 존재하는 값 제거
				check = false;
			}
		}

	}

	private static void removeChar(Stack<Node> stack, char[][] map) {
		while (!stack.isEmpty()) {
			Node tmp = stack.pop();
			int x = tmp.x;
			int y = tmp.y;

			map[x][y] = '.'; // 해당 위치를 점으로 바꿈

		}
	}

	private static void dfs(int depth, int x, int y, char[][] map, Stack<Node> stack) {
		int px = x, py = y;
		int ud[] = { -1, 0, 1, 0 };
		int rl[] = { 0, 1, 0, -1 };
		boolean check = false;
		for (int i = 0; i < 4; i++) {
			// 4방향으로 직진

			while (true) {
				int nx = x + ud[i]; // 다음 좌표 값
				int ny = y + rl[i];

				if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length) {
					// 범위를 벗어나는 경우
					check = true;
					break;
				}

				if (map[nx][ny] != '.') {
					// 문자나 벽이 존재할 경우
					break;
				}

				x = nx;
				y = ny;
			}

			if (check) {
				// 범위를 벗어나게 되는 경우
			} else {
				// 문자나 벽이 존재할 경우
				if (map[px][py] == map[x][y]) {
					// 문자가 같은 경우
					stack.add(new Node(px, py));
					stack.add(new Node(x, y));
					visited[x][y] = true;
				}
			}
		}
	}

	private static class Node {
		int x, y;

		public Node(int x, int y) {
			this.x = x;
			this.y = y;
		}
	}
}
