package samsung_Atype;

//색종이 붙이기
import java.util.*;
import java.io.*;

public class problem_17136 {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		Queue<Node> queue = new LinkedList<>();
		StringTokenizer st = null;
		int N = 10;
		int[][] map = new int[N][N];
		int[] paper = new int[5];

		// 색종이 초기화
		for (int i = 0; i < paper.length; i++)
			paper[i] = 5;

		for (int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine());
			for (int j = 0; j < N; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}

		int[][] tmpMap = new int[10][10];
		copyMap(map, tmpMap);
		outter: for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				if (map[i][j] == 1) {
					for (int k = 0; k < paper.length; k++) {

					}
					break outter;
				}
			}
		}
	}

	private static void copyMap(int[][] src, int[][] dest) {
		int idx = 0;
		for (int[] tmp : src) {
			System.arraycopy(tmp, 0, dest[idx++], 0, tmp.length);
		}
	}

	private static boolean isCovered(int x, int y, int[][] map, int [] paper, int k) {
		if (paper[k] != 0) {
			// 색종이의 개수가 아직 남아 있다면 해당 색종이의 크기로 덮이는지 확인한다.
			for (int i = x; i < k + 1; i++) {
				for (int l = y; l < k + 1; l++) {
					if (map[i][l] == 0) {
						return false;
					}
				}
			}
			paper[k] -= 1; // 색종이 감소 후 색종이로 덮는다.
			for (int i = x; i < k + 1; i++) {
				for (int l = y; l < k + 1; l++) {
					map[i][l] = 0;
				}
			}
			return true;
		}

		return false;
	}

	private static boolean isFinish(int[][] map) {
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if (map[i][j] == 1)
					return false;
			}
		}

		return true;
	}

	private static class Node {
		int[][] map;
		int[] paper;
		int count;

		public Node(int[][] map, int[] paper, int count) {
			this.paper = new int[paper.length];
			System.arraycopy(paper, 0, this.paper, 0, paper.length);
			this.map = new int[10][10];
			int idx = 0;
			for (int tmp[] : map) {
				System.arraycopy(tmp, 0, this.map[idx++], 0, tmp.length);
			}
			this.count = count;
		}

	}
}
