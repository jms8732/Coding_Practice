package samsung;

//나무 재테크

import java.util.*;
import java.io.*;

public class problem_16235 {
	static int N;
	public static void main(String [] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());
		int K = Integer.parseInt(st.nextToken());
		
		int [][] winterEnergy = new int[N+1][N+1]; //겨울에 줄 에너지
		ground g[][]=  new ground[N+1][N+1];
		
		for(int i =1 ; i<= N ; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j =1 ; j<= N ; j++) {
				int energy = Integer.parseInt(st.nextToken());
				g[i][j] = new ground();
				winterEnergy[i][j] = energy;
			}
		}
		
		long start = System.currentTimeMillis();
		for(int i =0 ; i< M ; i++) {
			st = new StringTokenizer(br.readLine());
			int x = Integer.parseInt(st.nextToken());
			int y = Integer.parseInt(st.nextToken());
			int tree = Integer.parseInt(st.nextToken());
			g[x][y].tree.add(tree);
		}
		
		for(int i =0 ; i < K ; i++) {
			spring_summer(g);
			Autumn(g);
			winter(g,winterEnergy);
		}
		
		int aliveTree = 0;
		
		for(int i =1 ; i<=N ; i++) {
			for(int j =1 ; j<= N ; j++) {
				aliveTree += g[i][j].tree.size();
			}
		}
		long end = System.currentTimeMillis();
		System.out.println("time : " + (end-start)/1000.0);
		System.out.println(aliveTree);
	}
	
	private static void spring_summer(ground[][] g) {
		for(int i =1 ; i<=N ; i++) {
			for(int j =1 ; j<=N ; j++) {
				int currentEnergy = g[i][j].energy;
				int size = g[i][j].tree.size();
				int deadEnergy = 0;
				Queue<Integer> tmpQ = new LinkedList<>(g[i][j].tree);
				
				
				for(int t=  0 ; t < size;  t++) {
					int treeOld = tmpQ.poll();
					if(treeOld > currentEnergy) {
						//나무가 양분을 얻지 못하고 죽음
						deadEnergy += treeOld /2;
					}else {
						//자신의 나이만큼 양분을 먹고 나이 1 증가
						currentEnergy -= treeOld;
						tmpQ.add(treeOld+1);
					}
				}
				
				//여름, 각각의 죽은 나무마다 나이를 2로 나눈 값이 나무가 있던 칸에 양분 추가
				g[i][j].energy = currentEnergy + deadEnergy;
				g[i][j].setTree(tmpQ);
			}
		}
	}
	
	private static void Autumn(ground [][] g) {
		int [] ud = {-1,-1,-1, 0, 0, 1, 1, 1};
		int [] rl = {-1, 0, 1,-1, 1,-1, 0, 1};
		for(int i =1; i <=N ; i++) {
			for(int j = 1 ; j <=N ; j++) {
				int size = g[i][j].tree.size();
				Queue<Integer> tmpQ = new LinkedList<>(g[i][j].tree);
				
				for(int k =0 ; k <size ; k ++) {
					int currentTree = tmpQ.poll();
					if(currentTree % 5 == 0) {
						//번식하는 나무의 나이가 5의 배수인 경우
						for(int n  =0 ; n< ud.length ; n++) {
							int nx = i + ud[n];
							int ny = j + rl[n];
							
							if(nx < 1 || nx >= g.length || ny < 1 || ny >= g.length) {
								continue;
							}
							
							//새로운 나무 추가
							g[nx][ny].tree.add(1);
						}
					}
					tmpQ.add(currentTree);
				}
				
				g[i][j].setTree(tmpQ);
			}
		}
	}
	
	private static void winter(ground[][] g, int[][] energy) {
		for(int i =1 ; i<=N ; i++) {
			for(int j =1 ; j<=N; j++) {
				g[i][j].energy += energy[i][j];
			}
		}
	}
	
	private static class ground{
		PriorityQueue<Integer> tree;
		int energy;
		public ground() {
			this.energy = 5;
			tree =new PriorityQueue<Integer>(); //트리를 나이 순으로 오름차순 정렬
		}
		
		public void setEnergy(int energy) {
			this.energy += energy;
		}
		public void setTree(Queue<Integer> queue) {
			this.tree =new PriorityQueue<Integer>(queue);
		}
	}
}
