package programmers2;

import java.util.*;

public class problem_11 {
	public int[][] solution(int n){
		Queue<Node> queue =new LinkedList<>();
		Deque<Integer> list = new LinkedList<>();
		Deque<Integer> dq []= new LinkedList[3];
		
		//첫 번째 기둥에 원판을 순서대로 넣기
		for(int i= 0 ;i < n ; i++) list.offer(i+1);
		
		for(int i = 0; i< dq.length ; i++) dq[i] =new LinkedList<>();
		
		int currentPosition = 0;
		
		int value = list.pollFirst();
		
		
		//맨 처음 값 넣기
		for(int i =0 ; i < 3 ; i++) {
			if(i != currentPosition) {
				dq[i].offer(value);
			}
		}
		
		queue.add(new Node(dq,1));
		
		while(!queue.isEmpty()) {
			Node current = queue.poll();
			int currentCount = current.count;
			Deque<Integer>[] currentlist = current.list;
			Deque<Integer>[] tmplist = new LinkedList[3];
			
			for(int i =0 ; i< 3 ; i++) {
				int cp = i;
				int cv = currentlist[i].peek();
				
				if(isFinish(currentlist,n)) {
					
				}
				
				for(int j =0 ; j< 3 ; j++) {
					if(cp != j ) {
						//현재 기둥에 다른 기둥
						int apv = currentlist[j].peek();
						if(cv < apv) {
							//다른 기둥에 값이 현재 꺼낸 원판보다 값이 클 경우
							copyArray(currentlist,tmplist);
							currentlist[j].addFirst(cv); //현재 위치의 앞에 넣을 수 있다.
							currentlist[i].poll();
							queue.add(new Node(currentlist,currentCount+1));
							copyArray(tmplist,currentlist);
						}
					}
				}
			}
			
		}
		
	}
	
	private static boolean isFinish(Deque<Integer> dq[], int n) {
		if(dq[2].size() == n)
			return true;
		return false;
	}
	
	//배열 값 복사
	private static void copyArray(Deque<Integer>[] src,Deque<Integer>[] dest) {
		for(int i = 0; i < src.length ; i++) {
			dest[i] = new LinkedList<>(src[i]);
		}
	}
	
	private static class Node{
		Deque<Integer> list[];
		int count;
		
		public Node(Deque<Integer>[] list, int count) {
			this.list = new LinkedList[3];
			copyArray(list);
			this.count = count;
		}
		
		//배열 복사
		private void copyArray(Deque<Integer>[] list) {
			for(int i =0 ; i< list.length ; i++) {
				this.list[i] = new LinkedList<>(list[i]);
			}
		}
	}
}
