package programmers2;

import java.util.*;

public class problem_11 {
	public static void main(String[] args) {
		int[][] answer = solution(2);
		for (int[] tmp : answer) {
			for (int i = 0; i < tmp.length; i++) {
				System.out.print(tmp[i] + " ");
			}
			System.out.println();
		}
	}

	public static int[][] solution(int n) {
		Queue<Node> queue = new LinkedList<>();
		Queue<Queue<List<Integer>>> closedList = new LinkedList<>();
		Deque<Integer> list = new LinkedList<>();
		Deque<Integer> dq[] = new LinkedList[3];

		// 첫 번째 기둥에 원판을 순서대로 넣기
		for (int i = 1; i <= n; i++)
			list.offer(i);

		for (int i = 0; i < dq.length; i++)
			dq[i] = new LinkedList<>();

		int currentPosition = 0;
		dq[0] = list;
		int value = list.pollFirst();

		// 맨 처음 값 넣기
		for (int i = 0; i < 3; i++) {
			List<Integer> tmpList = new ArrayList<>();
			if (i != currentPosition) {
				Queue<List<Integer>> tmpQueue = new LinkedList<>();
				tmpList.add(currentPosition + 1);
				tmpList.add(i + 1);

				dq[i].offer(value);
				tmpQueue.add(tmpList);
				queue.add(new Node(dq, tmpQueue));
				dq[i].poll();
			}
		}

		int[][] answer = null;

		while (!queue.isEmpty()) {
			Node current = queue.poll();
			Deque<Integer>[] currentlist = current.list;
			Deque<Integer>[] tmplist = new LinkedList[3];
			Queue<List<Integer>> cq = current.answer;
			
			if (isFinish(currentlist, n)) {
				answer = new int[cq.size()][2];
				copyAnswer(answer, cq);
				break;
			}
			
			if (!closedList.contains(cq)) {
				closedList.add(cq);
				Queue<List<Integer>> tmpQueue = new LinkedList<>(cq);

				for (int i = 0; i < 3; i++) {
					int cp = i;
					int cv = 0;

					if (!currentlist[i].isEmpty()) {
						// 현재 기둥에 원판이 존재할 경우에만 진행한다.
						cv = currentlist[i].peek();

						for (int j = 0; j < 3; j++) {
							List<Integer> tmpList = new ArrayList<>();
							if (cp != j) {
								// 현재 기둥에 다른 기둥
								int apv = 0;

								if (!currentlist[j].isEmpty())
									apv = currentlist[j].peek();

								if (cv < apv || currentlist[j].isEmpty()) {
									// 다른 기둥에 값이 현재 꺼낸 원판보다 값이 클 경우
									tmplist = copyArray(currentlist);
									if (!currentlist[i].isEmpty())
										currentlist[j].addFirst(cv); // 현재 위치의 앞에 넣을 수 있다.
									currentlist[i].poll();
									tmpList.add(cp + 1);
									tmpList.add(j + 1);
									cq.add(tmpList);
									queue.add(new Node(currentlist, cq));
									currentlist = copyArray(tmplist);
									cq = new LinkedList<>(tmpQueue);
								}
							}
						}
					}
				}
			}
		}
		return answer;
	}

	private static void copyAnswer(int[][] answer, Queue<List<Integer>> queue) {
		int rowIdx = 0;
		while (!queue.isEmpty()) {
			List<Integer> list = queue.poll();
			for (int i = 0; i < list.size(); i++) {
				answer[rowIdx][i] = list.get(i);
			}
			rowIdx++;
		}
	}

	private static boolean isFinish(Deque<Integer> dq[], int n) {
		if (dq[2].size() == n)
			return true;
		return false;
	}

	// 배열 값 복사
	private static Deque<Integer>[] copyArray(Deque<Integer>[] src) {
		Deque<Integer>[] tmp = new Deque[3];
		for (int i = 0; i < src.length; i++) {
			tmp[i] = new LinkedList<>(src[i]);
		}

		return tmp;
	}

	private static class Node {
		Deque<Integer> list[];
		Queue<List<Integer>> answer;

		public Node(Deque<Integer>[] list, Queue<List<Integer>> position) {
			this.list = new LinkedList[3];
			copyArray(list);
			this.answer = new LinkedList<>(position);
		}

		// 배열 복사
		private void copyArray(Deque<Integer>[] list) {
			for (int i = 0; i < list.length; i++) {
				this.list[i] = new LinkedList<>(list[i]);
			}
		}
	}
}
