package bitmask;

//발전소
import java.util.*;
import java.io.*;

public class problem_1102 {
	static int N,P;
	static int [][] cost;
	public static void main(String[] args) throws IOException{
		BufferedReader br =new BufferedReader(new InputStreamReader(System.in));
		
		N = Integer.parseInt(br.readLine());
		cost = new int[N][N];
		StringTokenizer st = null;
		
		for(int i =0 ; i< N ; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j =0 ; j< N ; j++) {
				cost[i][j] = Integer.parseInt(st.nextToken());
			}
		}
		
		String tmp = br.readLine();
		int light = 1<<N ;
		
		//발전소에 불이 들어온 것을 비트로 표현
		for(int i =0 ; i< tmp.length() ; i++) {
			if(tmp.charAt(i) == 'Y') {
				light |= 1<<i;
			}
		}
		
		P = Integer.parseInt(br.readLine());
		
		bfs(light);
	}
	
	private static void bfs(int light) {
		Queue<Node> queue =new LinkedList<>();
		int small = Integer.MAX_VALUE;
		//초기값
		queue.add(new Node(light,0));
		
		while(!queue.isEmpty()) {
			Node current = queue.poll();
			
			int cb = current.bit;
			
			//최소 발전기의 수가 P만큼 켜져 있을 경우
			if(Integer.bitCount(cb) == P) {
				small = Math.min(small, current.value);
			}else {
				//그렇지 않은 경우
				for(int i =0 ; i < N ; i++) {
					if((cb & (1<<i)) == (1<<i)) {
						//현재 위치에 발전기가 켜진 경우
						for(int j = 0 ; j< N ; j++) {
							if((cb & (1<<j)) == 0){
								//세로
								queue.add(new Node(cb | 1<<j,current.value+cost[i][j]));
								
							}
						}
					}
				}
			}
			
			
		}
		
		if(small != Integer.MAX_VALUE) {
			System.out.println(small);
		}else
			System.out.println(-1);
	}
	
	private static class Node{
		int bit, value;
		public Node(int b, int v) {
			this.bit =b;
			this.value = v;
		}
	}
}
