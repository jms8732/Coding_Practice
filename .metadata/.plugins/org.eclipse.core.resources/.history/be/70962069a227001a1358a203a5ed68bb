package programmers1;

//리틀 프랜즈

import java.util.*;

public class problem_17 {
	static int ud[] = { -1, 0, 1, 0 };
	static int rl[] = { 0, 1, 0, -1 };

	public static void main(String[] args) {
		String[] s = { "NRYN", "ARYA"};
		String result = solution(2, 4, s);
		System.out.println(result);
	}

	public static String solution(int m, int n, String[] board) {
		char[][] map = new char[m][n];
		Queue<Character> queue = null;
		Set<Character> set = new TreeSet<>(); // 문자를 오름차순으로 정렬
		// map 초기화
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				map[i][j] = board[i].charAt(j);
				if (map[i][j] >= 'A' && map[i][j] <= 'Z')
					set.add(map[i][j]);
			}
		}

		queue = new LinkedList<>(set);
		Queue<Character> queue1 = new LinkedList<>(queue);
		StringBuilder sb = new StringBuilder();
		
		while (!queue.isEmpty()) {
			char target = queue.poll();

			outter: for (int i = 0; i < m; i++) {
				for (int j = 0; j < n; j++) {
					if (map[i][j] == target) {
						// 발견했을 경우 이동
						boolean result = move(i, j, map);
						if (result) {// 사천성이 터졌을 경우
							queue = sort(queue);
							sb.append(target);
						} else {
							queue.add(target);
						}
						break outter;
					}
				}
			}
			
			if(queue1.equals(queue))
				return "IMPOSSIBLE";

		}
		if (sb.toString().isEmpty())
			return "IMPOSSIBLE";
		return sb.toString();
	}

	private static boolean move(int x, int y, char[][] map) {
		int tmpX = x, tmpY = y;
		for (int i = 0; i < 4; i++) {
			int nx = x + ud[i];
			int ny = y + rl[i];

			if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length) // 범위를 벗어나는 경우
				continue;

			if (map[nx][ny] == map[x][y]) {
				// 현재 위치와 다음위치의 값이 같은 경우
				map[nx][ny] = '.';
				map[x][y] = '.';
				return true;
			}

			if (map[nx][ny] == '.') {
				x = nx;
				y = ny;
				while (true) {
					nx = x + ud[i];
					ny = y + rl[i];
					if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length )
						break;
					
					if(map[nx][ny] != '.') {
						x = nx;
						y = ny;
						break;
					}

					x = nx;
					y = ny;
				}
				
				if (!check(tmpX, tmpY, x, y, i, map)) {
					x = tmpX;
					y = tmpY;
				}else
					return true;
			}
		}

		return false;
	}

	private static boolean check(int ox, int oy, int x, int y, int direction, char[][] map) {
		int tmpX = ox, tmpY = oy;
		direction = (direction + 1) % 4;
		for (int i = 0; i < 2; i++) {
			while (true) {
				int nx = x + ud[direction];
				int ny = y + rl[direction];

				if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length)
					break;

				if (map[nx][ny] != '.') {
					x = nx;
					y = ny;
					break;
				}
				x = nx;
				y = ny;
			}

			if (map[x][y] == map[tmpX][tmpY]) {
				map[x][y] = '.';
				map[tmpX][tmpY] = '.';
				return true;
			}
			direction = (direction + 2) % 4;
		}
		return false;
	}

	private static Queue<Character> sort(Queue<Character> queue) {
		TreeSet<Character> set = new TreeSet<>(queue); // 현재 문자 오름차순으로 정렬
		queue = new LinkedList<>(set); // 정렬된 문자를 다시 큐에 삽입
		return queue;
	}
}
