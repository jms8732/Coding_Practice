package programmers1;

//리틀 프랜즈

import java.util.*;

public class problem_17 {
	static int ud[] = { -1, 0, 1, 0 };
	static int rl[] = { 0, 1, 0, -1 };

	public static void main(String[] args) {
		String[] s = { "DBA", "C*A", "CDB" };
		String result = solution(3, 3, s);
		System.out.println(result);
	}

	public static String solution(int m, int n, String[] board) {
		char[][] map = new char[m][n];
		Queue<Character> queue = null;
		Set<Character> set = new TreeSet<>(); // 문자를 오름차순으로 정렬
		// map 초기화
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				map[i][j] = board[i].charAt(j);
				if (map[i][j] >= 'A' && map[i][j] <= 'Z')
					set.add(map[i][j]);
			}
		}

		queue = new LinkedList<>(set);
		
		StringBuilder sb = new StringBuilder();
		boolean check = false;
		while (!check) {
			check = true;
			char target = queue.poll();

			outter : for (int i = 0; i < m; i++) {
				for (int j = 0; j < n; j++) {
					if (map[i][j] == target) {
						// 발견했을 경우 이동
						boolean result = move(i, j, map);
						if (result) {// 사천성이 터졌을 경우
							check = false;
							sort(queue);
							sb.append(target);
						}
						else {
							queue.add(target);
						}
						break outter;
					}
				}
			}
			
		}
		if(sb.toString() == null)
			return "IMPOSSIBLE";
		return sb.toString();
	}

	private static boolean move(int x, int y, char[][] map) {
		for (int i = 0; i < 4; i++) {
			int nx = x + ud[i];
			int ny = y + rl[i];

			if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length) // 범위를 벗어나는 경우
				continue;

			if (map[nx][ny] == map[x][y]) {
				// 현재 위치와 다음위치의 값이 같은 경우
				map[nx][ny] = '.';
				map[x][y] = '.';
				return true;
			}

			if (map[nx][ny] == '.') {
				while (true) {
					nx = x + ud[i];
					ny = y + rl[i];
					if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length)
						break;

					x = nx;
					y = ny;
				}
				check(x, y,i, map);
			}
		}

		return false;
	}

	private static boolean check(int x, int y, int direction, char[][] map) {
		int tmpX = x, tmpY = y;
		direction = (direction + 1) % 4;
		for(int i = direction ; i <= 4; i *= 2) {
			int nx = x + ud[i];
			int ny = y + rl[i];

			if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length)
				break;

			if(map[nx][ny] != '.')
			{
				x = nx;
				y = ny;
				break;
			}
			x = ny;
			y = ny;
		}
		
		if(map[x][y] == map[tmpX][tmpY])
		{
			map[x][y] = '.';
			map[tmpX][tmpY] = '.';
			return true;
		}
		
		return false;
	}

	private static void sort(Queue<Character> queue) {
		TreeSet<Character> set = new TreeSet<>(queue); // 현재 문자 오름차순으로 정렬
		queue = new LinkedList<>(set); // 정렬된 문자를 다시 큐에 삽입
	}
}
