package programmers;
//섬 연결하기

import java.util.*;
public class problem_31 {
	static int cost[][];
	public static void main(String[] args) {
		
	}
	public static int solution(int n, int[][] costs) {
		cost = new int [n][n];
		for(int i = 0 ; i< cost.length ; i++) {
			cost[costs[i][0]][costs[i][1]] = costs[i][2]; //비용 추가
			cost[costs[i][1]][costs[i][0]] = costs[i][2]; //무 방향성이므로 반대쪽도 추가
		}
		
		bfs(0);
        int answer = 0;
        return answer;
    }
	
	public static void bfs(int x) {
		Queue<Integer> queue= new LinkedList<>();
		for(int i =0 ; i< cost[x].length ; i++) {
			if(cost[x][i] != 0)
			{
				queue.add(i); //y좌표 삽입
			}
		}
	
		island first=  new island(x,0,queue);
		
		Queue<island> q = new LinkedList<>();
		q.add(first);
		int totalCost = Integer.MAX_VALUE;
		while(!q.isEmpty()) {
			island tmp = q.poll();
			int tmpX = tmp.current;
			if(tmp.next.isEmpty())
				totalCost = Math.min(totalCost, tmp.cost);
			List<Integer> tmpV = new Vector<>(tmp.next);
			while(!tmp.next.isEmpty()) {
				int y= tmp.next.poll(); //다음 좌표
				int tmpCost = cost[tmpX][y];
				Queue<Integer> tmpQueue = new LinkedList<>();
				for(int i =0 ; i< tmpV.size() ; i++) {
					if(y == tmpV.get(i))
						continue;
					tmpQueue.add(tmpV.get(i));
				}
				island i = new island(y,tmpCost,tmpQueue);
				q.add(i);
			}
		}
		
	}
}

class island{
	int current;
	Queue<Integer> next;
	int cost =0 ;
	public island(int current,int cost, Queue<Integer> queue) {
		this.current = current;
		next = new LinkedList<>(queue);
		this.cost += cost;
		
	}
}
