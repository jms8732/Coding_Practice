package samsung;
//로봇 청소기

import java.util.*;
import java.io.*;

public class problem_14503 {
	static int map[][];
	static int rl[] = { 0, -1, 0, 1 }; // 동쪽 서쪽
	static int ud[] = { -1, 0, 1, 0 }; // 북쪽 남쪽
	static boolean visited[][]; // 로봇이 청소했는가를 판단하는 이차원 배열
	static boolean disactivate;
	static int count; // 로봇이 청소한 구역

	public static void main(String[] args) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = null;
		try {
			st = new StringTokenizer(br.readLine()); // 읽어들임
			int x = Integer.parseInt(st.nextToken());
			int y = Integer.parseInt(st.nextToken());
			map = new int[x][y]; // 맵 생성
			visited = new boolean[x][y];

			st = new StringTokenizer(br.readLine()); // 다음 라인 읽어드림
			int robotX = Integer.parseInt(st.nextToken());
			int robotY = Integer.parseInt(st.nextToken());

			int direction = Integer.parseInt(st.nextToken()); // 방향

			// 맵 값 넣기
			for (int i = 0; i < x; i++) {
				st = new StringTokenizer(br.readLine());
				for (int j = 0; j < y; j++) {
					map[i][j] = Integer.parseInt(st.nextToken());
				}
			}

			dfs(robotX, robotY, direction);
			System.out.println(count);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static void dfs(int x, int y, int direction) {
		int initialDirection = direction; // 초기 위치
		direction = (direction + 1) % 4;
		while (true) {
			if (!visited[x][y]) {
				// 현재 좌표가 방문을 안했을 경우
				count++;
				visited[x][y] = true;
			}

			if (disactivate)
				break;

			// 다음 좌표 설정
			int nx = x + ud[direction];
			int ny = y + rl[direction];

			if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[nx].length) // 다음 좌표값이 범위를 넘어가는 경우
				continue;

			if (!visited[nx][ny] && map[nx][ny] != 1) {
				// 다음 좌표값이 방문하지 않았을 경우
				x = nx;
				y = ny;
			} else if (initialDirection == direction) {
				// 네 방향을 다 돌았을 경우
				if (which(x, y, direction)) {
					// 네 방향이 모두 방문했거나 벽이 존재하고, 뒤에 벽이 없을 경우
					switch (direction) {
					case 0: { // 방향이 북쪽인 경우, 남쪽에 벽이 있는지 판단
						x = x + 1;
						break;
					}
					case 1: { // 방향이 서쪽인 경우, 동쪽에 벽이 있는지 판단
						y = y + 1;
						break;
					}
					case 2: { // 방향이 남쪽인 경우, 북쪽에 벽이 있는지 판단
						x = x - 1;
						break;
					}
					case 3: { // 방향이 동쪽인 경우, 서쪽에 벽이 있는지 판단
						y = y - 1;
						break;
					}
					}
					initialDirection = direction;
					direction = (direction + 1) % 4;
				} else
					disactivate = true;
			} else
				direction = (direction + 1) % 4;// 방향 전환
		}
	}

	private static boolean which(int x, int y, int direction) {
		switch (direction) {
		case 0: { // 방향이 북쪽인 경우, 남쪽에 벽이 있는지 판단
			if (map[x + 1][y] == 1)
				return false;
			break;
		}
		case 1: { // 방향이 서쪽인 경우, 동쪽에 벽이 있는지 판단
			if (map[x][y + 1] == 1)
				return false;
			break;
		}
		case 2: { // 방향이 남쪽인 경우, 북쪽에 벽이 있는지 판단
			if (map[x - 1][y] == 1)
				return false;
			break;
		}
		case 3: { // 방향이 동쪽인 경우, 서쪽에 벽이 있는지 판단
			if (map[x][y - 1] == 1)
				return false;
			break;
		}
		}

		return true;
	}
}
